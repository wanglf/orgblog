#+TITLE: Linux内核进程管理
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil
#+LATEX_CLASS: latex-doc
#+PAGE_TAGS: linux kernel process

* 基本概念
** 进程管理
#+HTML: <!--abstract-begin-->

在Linux内核中用 =task_struct= 描述一个进程，也被称之为进程描述符。
该结构体很大，在32位机上有17KB，之所以这么大，
是因为要保存一个进程所需要知道的全部信息，如打开的文件，进程地址空间，
信号，进程状态等等。
进程描述符可以通过 =thread_info= 查找，对于向下生长的栈，
这个结构保存在栈底，
内核提供了一个接口 =current_thread_info()->task= 用于获取进程描述符。
每个进程有一个进程编号，系统支持的最大进程编号可以通过文件
=/proc/sys/kernel/pid_max= 查看。

#+HTML: <!--abstract-end-->

进程有三个状态：
- TASK_RUNNING :: 表示进程可以运行，此时进程要么在运行，要么在等待运行
- TASK_INTERRUPTIBLE :: 进程在休眠，等待某种条件发生，当被信号中断的时候，
     进程就进入RUNNING状态
- TASK_UNINTERRUPTIBLE :: 进程等待某种条件发生，即便被信号中断也不会唤醒

*** 创建进程
用户通过fork()创建子进程，内核中采用一种称为COW的技术，
通过copy-on-write的方式来减少复制，
也就是当子进程真正要写入的时候才会复制地址空间的页面。
所以在写入之前，fork()只会复制父进程的页表并生成一个进程ID号。
还有一个vfork()，相比fork()的好处就是不复制父进程的页表，
因为不复制页表，所以子进程不能去写地址空间，由于这样的限制，
现在已经不推荐用vfork()了。

在Linux中不区分进程和线程，创建线程都是通过clone()来实现的，
例如fork()在底层也是调用clone()。
Linux还有一种内核线程，通过 =kthread_run()= 创建。
** 进程调度
进程调度面临一个问题，就是不同类型的进程，需要不同的调度方式。
简单来说就是交互式进程需要快速响应，而批操作进程需要高吞吐量。
要调度进程，需要有一些指标来作为参数。
最基本的参数是优先级，Linux提供了两种优先级指标。

1. nice值的范围是(-20, 19)，值越大越友好，因此优先级越低。
2. real-time优先级范围是(0, 99)，值越大，优先级越高。

时间片用来表示一个进程在被抢占之前需要运行的时间，
传统的UNIX系统根据nice值计算时间片。
这样的方法简单，但是存在如下一些问题：
1. 同低同高问题，假定nice0分配100ms，nice20分配5ms，
   如果是两个nice0，各执行100ms再切换，
   如果是两个nice20，则各执行5ms就要切换。
2. 非线性问题，如nice0和nice1，分配100ms和95ms，
   而nice19和nice20，分配10ms和5ms，
   虽然相邻相差为5ms，但是nice19却是nice20的总时间两倍。
3. 时间片受系统计时精度影响。

Linux引入一个叫CFS调度，让每个进程获取总时间的\( \frac{1}{n} \)，
而nice值则用来增加权重。

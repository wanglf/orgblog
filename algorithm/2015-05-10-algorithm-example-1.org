#+TITLE: 算法习题集1
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil
#+LATEX_CLASS: latex-doc
#+PAGE_TAGS: algorithm

* 数值计算
** 位运算习题
1. 给定一个实数，如3.72，打印二进制表示，如果不能精确用二进制表示，打印ERROR。
2. 给定一个整数，打印下一个最小和前一个最大的整数，
   满足和给定整数二进制表示法1的位数总数相同。
3. 写一个程序实现位交换，b0/b1，b2/b3依次类推。
4. 写一个程序计算一个整数中二进制表示1的个数。
5. 数组A[1..n]包括整数0..n中的所有整数，很显然有一个整数丢了，
   如何找出这个整数。限定条件是不能直接访问A[i]，
   只提供函数bit(i, j)用于访问A[i]的第j位。
*** 位运算习题提示
1. 本题实际是个进制转换问题，整数部分的转换规则为：
   =b1 = n, n = n/2; b2 = n; n = n/2; ...= 整数部分为 $b_i ... b_2 b_1$ 。
   小数部分的转换规则为：
   =c1 = int(2f), f = 2f - c1; c2 = int(2f), f = 2f - c2; ...=
   小数部分为 $c_1 c_2 ... c_i$ 。
2. 查找下一个最小的数很好找，找到最右边的1，向左搜索第一个0，将其置1，
   再将其右边的1置0。这还不够小，还需要将右边所有的1全部移到最右边去。

   同样的方法可以找前一个最大的数，找到最左边的0，注意必须在最高位右边，
   将其置1，再将其左边的1置0。这还不够大，将右边所有的1全部移到挨着该位的位置。
3. ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)
4. 利用 =n & (n -1)= 可以消掉最末一位。
5. 这个题目用到一个二进制表示中的特性，即低位的0和1个数是对称的。
   这句话的意思是任何一个位，0的个数和1的个数相同。
   如果缺少的那个数b0为0，那么统计b0就会发现0的个数就会比1少一个，依次类推。

   对于最高位在处理上还有点技巧，比较简单的做法是将n对齐到 $2^{k} - 1$ ，
   并假定大于n的数都没有丢失。

* 顺序数据结构
** 数组习题
#+HTML: <!--abstract-begin-->
1. 给定一个字符串，确定其中是否每个元素都只出现了一次。
2. 编写一个程序，删除字符串中所有的重复出现的字符，只需删除重复部分。
3. 判断两个字符串是否为变位词，所谓变位是指可以只通过调整字符位置让两个字符相同。
4. 给定一个函数is_substring(s1, s2)用于判断s1是否为s2的子字符串，
   仅使用该函数如何确定两个字符串是否可以通过循环移位使其相同。
5. 给定一个 $N \times N$ 矩阵，将其顺时针旋转90度。
6. 给定一个 $N \times N$ 矩阵，如果一个元素为0，将其所在的行和列都置0。
#+HTML: <!--abstract-end-->

*** 数组习题提示
1. 使用位图标记已经出现的字符。
2. 查询位图删除已经出现的字符。
3. 使用数组统计每个字符出现的次数。
4. is_substring(s1, s2+s2)。
5. 四个角落的点循环移位。
6. 用两个数组统计需要置零的行和列，本题的陷阱是置0后会影响后面的判断。

** 链表习题
1. 删除链表中的重复元素。
2. 查找链表倒数第n个元素。
3. 给定一个单向链表中间节点，如何删除该节点。
4. 查找一个循环链表的入口点。

*** 链表习题提示
1. 提供两种思路：通过hash表保存已出现元素，通过遍历舍弃已出现元素。
2. 两个相距n个节点的指针同时前进。
3. 将后面的元素依次向前复制。
4. 利用数学公式：假定链长为 $l$ ，环长为 $c$ ，p1和p2前进速度分别为1和2。
   相遇时假定p1走了 $l+a$ ，并假定 $a=kc + x$ ，那么有 $l+x = nc$ ，
   且 $x < c$ 。此时置p1为起点，p2不变，p1和p2同步前进，
   相遇的时候p2相对于入口点正好走 $l + x$ ，也就是正好回到入口点。

** 堆栈和队列
1. 如何实现一个栈能够以 $O(1)$ 的效率返回栈中的最小值。
2. 如何通过两个栈来实现队列。
3. 使用给定的方法给栈排序：push()、pop()、peek()、is_empty()。
4. 将许多个已排序的文件合并为一个大文件。

*** 堆栈和队列提示
1. 维护一个最小值栈，并且修改pop()/push()方法，
   push()出现小于或等于最小值的时候，就向最小值栈同步push()该值。
2. 一个栈用于出队，一个栈用于入队，出队为空时，将入队栈全部放到出队栈。
3. 需要额外一个栈来保存以排序部分，从未排序栈抽出一个元素。
   如果该值较小，就将已排序栈中的数据逐个压入未排序栈，
   插入当前值到已排序栈正确位置之后，再从未排序栈逐个压入到已排序栈。
4. 维护一个堆，插入每个文件的第一个元素，当从堆抽取一个元素时，
   就将该元素所在文件的后继插入堆中。

* 网状数据结构
** 树和图
1. 判断一个二叉树是否是平衡树。
2. 编写一个二叉树非递归中序遍历。
3. 编写一个二叉搜索树的插入删除操作。
4. 给定一个已排序数组，创建一个高度最小的二叉树。
5. 给定一个二叉树，为每层创建一个链表包含该层所有元素。
6. 给定二叉树中的一个节点，找其IN-order遍历的下一个节点。
7. 给定二叉树中任意两个节点，找其最小公共祖先，注意不一定是二叉搜索树。
8. 给定两个二叉树，判断其中一个是否是另一个的子树，假定树的规模很大。
9. 给定一个二叉树，每个节点包含一个值，打印节点相加的和为给定值的所有路径。
10. 给定一个有向图中的两点，判断两者之间是否有路径可达。

*** 树和图提示
1. 只需要比较最高和最低深度的差距即可。
   #+BEGIN_SRC cpp
int max_depth(node root)
{
    return 1 + max(max_depth(root.left), max_depth(root.right));
}
int min_depth(node root)
{
    return 1 + min(min_depth(root.left), min_depth(root.right));
}
   #+END_SRC

2. 一种方法可以用栈来保存元素。
   一种方法可以找到最左端元素，然后反复查找后继来完成。

3. 为了简单，给出算法导论中的示例代码：
   #+BEGIN_SRC python
def tree_insert(root, node):
    x, pos = root, root
    while x:
        pos = x
        x = x.left if node < x else x.right
    node.parent = pos
    if not pos:
        root = node
    elif node < pos:
        pos.left = node
    else:
        pos.right = node
   #+END_SRC
   删除就比较复杂了，要分几种情况：
   - node没有子节点，可以直接删除
   - node只有一个孩子，将孩子替换该节点
   - node有两个孩子，要找到后继，并将node的左子树放到后继的左子树中
   #+BEGIN_SRC python
def tree_replace_subtree(T, a, b):
    "replace subtree a by subtree b"
    if not a.parent:
        T = b
    elif a == a.parent.left:
        a.parent.left = b
    else:
        a.parent.right = b
    if b:
        b.parent = a.parent

def tree_remove(T, node):
    if not node.left:
        tree_replace_subtree(T, node, node.right)
    elif not node.right:
        tree_replace_subtree(T, node, node.left)
    else:
        next = tree_min(node.right)
        if next.parent != node:
            tree_replace_subtree(T, next, next.right)
            next.right = node.right
            next.right.parent = next
        tree_replace_subtree(T, node, next)
        next.left = node.left
        next.left.parent = next
   #+END_SRC
4. 搞清楚二叉搜索树和数组的对应关系，用一个简单的递归式即可完成。
   #+BEGIN_SRC cpp
node tr_add(int *arr, int start, int end)
{
    int mid;

    if (end < start)
        return NULL;

    mid = (start + end) / 2;
    node n = new node(arr[mid]);
    n.left = tr_add(arr, start, mid - 1);
    n.right = tr_add(arr, mid + 1, end);

    return n;
}
   #+END_SRC

5. 首先root单属于一个链表，那么第2层链表就是root的子节点，
   第3层链表就是第2层链表中每个节点的字节点，依次类推即可。

6. 该题目比较难，需要分如下几种情况分别处理：
   1. X.right存在，那么下一个节点就是left_most(X.right)
   2. X = P.left，那么P就是下一个节点
   3. X = P.right，那么下一个节点就是next(P)
7. 如果是二叉搜索树，可以根据搜索路径来确定分叉节点。
   反过来可以找出A和B到根节点的路径，计算路径的相交点，通过链表很容易实现。
   另外一个比较有意思的解法是：如果A、B在P的一边，那么最小公共祖先一定是P的字节点，
   否则P就是A和B的最小公共祖先。
   #+BEGIN_SRC cpp
node min_ancestor(node root, node A, node B)
{
    if (root.left.has_node(A) && root.left.has_node(B))
        return min_ancestor(root.left, A, B);
    if (root.right.has_node(A) && root.right.has_node(B))
        return min_ancestor(root.right, A, B);
    return root;
}
   #+END_SRC
8. 创建一个前序遍历字符串和中序遍历字符串，如果A的两种字符串均是B的子字符串，
   那么可以确定A是B的子树。
   另外可以用一个典型的递归匹配算法来完成。
   #+BEGIN_SRC cpp
int __is_subtree(node A, node B)
{
    if (!A && !B)
        return 1;
    if (!A || !B)
        return 0;
    if (A.data != B.data)
        return 0;
    return __is_subtree(A.left, B.left) && __is_subtree(A.right, B.right);
}

int is_subtree(node A, node B)
{
    if (!A)
        return 1;
    if (!B)
        return 0;
    if (A.data == B.data) {
        if (__is_subtree(A, B))
            return 1;
    }
    return is_subtree(A, B.left) || is_subtree(A, B.right);
}
   #+END_SRC
9. 这个题目比较有难度，要对每一个节点作为起始遍历，并记录其所有路径。
   #+BEGIN_SRC cpp
void sum_path(node root, int sum, vector<int> &arr, int depth)
{
    if (!root)
        return;

    int tmp = sum;
    arr.push_back(root.data);
    for (int i = depth; i > -1; i--) {
        tmp -= arr[i];
        if (!tmp)
            print_msg(arr, i, depth);
    }

    vector<int> a1 = arr;
    vector<int> a2 = arr;
    sum_path(root.left, sum, a1, depth + 1);
    sum_path(root.right, sum, a1, depth + 1);
}
   #+END_SRC
10. 假定给定两点为A和B，从A开始进行遍历即可。
* 搜索与排序
** 排序与搜索
1. 有限正整数排序问题，给定一个文件，包含正整数，最大值小于 \( 10^7 \)，
   将其排序。
2. 给定一个字符串数组，通过排序将变位词排到一起。
3. 给定一个数组，数组是已经排序但经过旋转的，给定一个整数，用 $O(lgn)$ 的效率查找。
4. 给定一个字符串数组，该数组经过排序，但是中间随机插入了很多空字符串，
   如何从中搜索某个字符串。
5. 给定一个 $N \times N$ 的矩阵，行和列都是排序好的，查找给定数字。

*** 排序与搜索提示
1. 这是编程珠玑开篇的一题，采用位图来标记每个整数，
   如果知道输入数据最大重复数小于某个值，那么可以让每个整数占据多位。
   当然这种方法不能用于排序包含大量重复数的问题。
   这个题目还可以进一步问如果要限定内存大小怎么办，
   处理方式是可以找到中位数，将数值分成两半排序，或者分为多段排序。
2. 思路很简单，把比较函数替换为比较字符串的标准变位词即可。
3. 将搜索限制在一个区间，并计算区间的中位索引，[beg, mid, end]，
   通过判断要查找的数和这三个数之间的关系，以及这三个数本身的关系，
   确定会落在哪个区间。
4. 还是可以通过二分搜索来做，如果找到的中位是空字符串，就去向右找非空，
   否则搜索左半部。
5. 不能用二分法查找，从 =A[0][N-1]= 开始搜索，比给定小就往下走，比给定大就往左走。

* 特殊条件问题
** 大数据处理
1. *TOP K问题* 给定一个巨大文件，如1T，每行包含访问某个网站的IP，找出访问次数最多的10个IP。
2. *文件查重* 两个文件每行保存一个URL记录，大小都是50G，找出两个文件同时出现的URL记录。
3. *位图查找* 给40亿个不重复的 =unsigned int=，没有排序，如何给定整数是否在这40亿个给定的数中。
4. *中位数* 一个文件中有10G个整数，未排序，找出中位数，内存限制为2G。
5. *分布TOP K问题* 海量数据分布在10台电脑，统计出现的前10个。
6. *重复统计* 给定10亿个整数，统计不重复的整数个数，假定内存不够用。

*** 大数据处理提示
1. 将文件按照hash(IP) % 1024拆分为1024个文件，对每个文件中出现的IP建立hash集合，
   遍历文件统计每个IP出现次数。
   然后对每个文件中的访问按照次数排序，再归并，即可找到最大的10个IP。
   如果只需要找到最大的IP是不需要排序的。

   排序并不是最好的方法，对于TOP K问题最好是利用堆这个数据结构，维护一个规模为K的小根堆。
   遍历过程中发现元素出现次数大于堆根就更新堆。

2. 对每个文件根据hash映射划分为小文件，得到 \( a_1a_2 ... \)
   和 \( b_1b_2 ... \)，
   接下来可以将 $a_1$ 作为一个hash_set，查询 $b_1$ 中的URL是否在 \( a_1 \) 中出现，
   依次查询 $a_2b_2，a_3b_3$ 等等即可。
3. 假定 =unsigned int= 长度为32位，可以申请 $\frac{2^{32}}{8} = 512M$
   的空间用于建立位图，要判断某个整数是否存在，只需要确定位图中对应位是否为1。
4. 假定内存可以存放1M个整数，那么我们可以将整数划分为10K个范围，统计出每个范围内整数的个数，
   这样就可以确定出中位数出现在哪个范围中。如果对应范围中的整数个数仍然太多，
   可以进一步细分，最后通过对小范围内排序找到中位数。
5. 利用hash运算使得相同的元素保存在同一台电脑，然后统计每台电脑的前10个，最后归并。
6. 将数据划分到N个范围中，对每个范围用bitmap统计。

* 参考资料
- [[http://blog.csdn.net/v_JULY_v/article/details/6279498][十道海量数据处理面试题与十个方法大总结]]
- [[http://blog.csdn.net/v_july_v/article/details/7382693][教你如何迅速秒杀掉：99%的海量数据处理面试题]]


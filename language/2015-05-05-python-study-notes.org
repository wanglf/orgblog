#+TITLE: Python学习笔记
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil
#+LATEX_CLASS: latex-doc
#+PAGE_TAGS: python

* 语言要点
#+HTML: <!--abstract-begin-->

学习Python推荐一本书，叫 =Learning Python= ，
不过这里是另外一本书的笔记，这边书叫 =Python In a Nutshell= ，
涵盖第4章的内容，也就是对Python的基本语法进行介绍。
#+HTML: <!--abstract-end-->

Python对程序格式有较强的限定，如下所示：
- Python的注释符为 =#=
- Python行尾不需要加额外的字符以表示结束
  - 如果语句太长，可以对换行符转义，也就是在行尾加上 =\= 符号。
    如果括号或字符串没有配对，就没必要对换行符转义，
    因为Python知道此时一行语句没有结束。
- Python用相同缩进来表达同一语句块
  - 由于TAB的长度往往被修改，所以源代码中最好只有空格。
- Python源代码默认只接受ASCII字符集
  - 要使用其他字符集，需要加上编码声明，
    如 =# -*- coding: utf-8 -*-=

** 数据与操作
*** 数据类型
- 数字类型包括整型、浮点型和复数型
- 序列类型包括字符串、元组、列表
- 集合、字典
- 空类型是指None对象
- 可调用类型，在类型中实现了 =__call__= 方法
- 布尔类型，语义比较广泛，如空字典、空集合都是False

- 变量无需声明，del可以解除一个变量的名字绑定
- 引用成员用点操作符(=.=)，引用元素用下标操作符(=[]=)，
  引用调用函数用函数符(=()=)。

*** 简单操作
- 比较有趣的是链式表达，如下面两个表达式等价。
#+BEGIN_SRC python
  a < b <= c < d
  a < b and b <= c and c < d
#+END_SRC
- 三元表达方式如下所示。
#+BEGIN_SRC python
  returntrue if condition else returnfalse
#+END_SRC
- 所有序列都支持测试成员是否存在， =if item in seqs=

*** 列表操作
- 删除子序列可以用del操作符
#+BEGIN_SRC python
  x = [1, 2, 3, 4, 5]
  del x[1]                                # x = [1, 3, 4, 5]
  del x[::2]                              # x = [3, 5]
#+END_SRC

- l.count(x) :: x出现次数
- l.index(x) :: x出现下标
- l.append(x) :: 在尾部加入x
- l.extend(x) :: 在为不扩展x
- l.insert(i, x) :: 在下表i处插入x
- l.remove(x) :: 删除x第一次出现，如果未出现则引发异常
- l.pop([i]) :: 删除下表为i的元素，如果未指定i，就删除最后一个元素，
     返回删除的元素，如果下标越界，引发异常
- l.reverse() :: 反转
- l.sort(cmp=cmp, key=None, reverse=False) :: 排序，
     key的意思是比较key(x)而不是比较x本身。
*** 集合操作
- s.copy() :: shallow copyx
- s.difference(s1) :: s出现s1未出现
- s.intersection(s1) :: s和S1同时出现
- s.issubset(s1) :: s是s1的子集
- s.issuperset(s1) :: s1是s的子集
- s.symmetric_difference(s1) :: 只在s和s1其一出现
- s.union(s1) :: 在s或s1中出现
- s.add(x) :: 添加
- s.clear() :: 清除
- s.discard(x) :: 删除x，如果不存在也没关系
- s.pop() :: 随机弹出一个元素并返回
- s.remove(x) :: 如果未出现x会产生异常
*** 字典操作
- d.copy() :: shallow copy
- d.has_key(x) :: 测试是否有键x
- d.items()/d.iteritems() :: (key, value)对列表
- d.keys()/d.iterkeys() :: 键列表
- d.values()/d.itervalues() :: 值列表
- d.get(k[, x]) :: 这个函数非常有用，如果k存在就返回d[k]，
     否则返回x，如果未指定x就返回None
- d.clear() :: 清除
- d.update(d1) :: =for k in d1: d[k] = d1[k]=
- d.setdefault(k[, x]) :: 如果k存在就返回d[k]，
     否则将d[k]设置为x并返回
- d.pop(k[, x]) :: 弹出k，如果没有找到就返回x，
     注意如果没有指定x又没有找到k就会引发异常
- d.popitem() :: 随机弹出一个元素

** 流程控制
*** 分支语句
#+BEGIN_SRC python
  if condiiton:
      statements
  elif condition:
      statements
  else:
      statements
#+END_SRC

要判断一个变量是否为真，直接的方式是 =if x= ，
请不要使用如下的一些形式：
#+BEGIN_SRC python
  if x is True
  if x == True
  if bool(x)
#+END_SRC

*** 循环语句
#+BEGIN_SRC python
  while condition:
      statements
#+END_SRC

#+BEGIN_SRC python
  for item in iterable:
      statements
#+END_SRC

列表表达式(list comprehensions)是Python特有一个语法。
#+BEGIN_SRC python
  [expression for item in iterable clauses]
#+END_SRC

例如：
#+BEGIN_SRC python
  [x + 1 for x in range(10)]
  [x + 1 for x in range(10) if x % 2]
  [x + y for x in range(10) for y in range(10)]
#+END_SRC
*** 跳转语句
| break    | 退出循环       |
| continue | 进入下一轮循环 |

** 函数
#+BEGIN_SRC python
  def functionname(parameters):
      statements
#+END_SRC
*** 属性
#+BEGIN_SRC python :results output :exports both
  def sum_args(*nums):
      '''accept arbitrary numerical arguments and return their sum'''
      return sum(nums)

  print sum_args.__name__
  print sum_args.__doc__
  print sum_args(1, 2, 3)
#+END_SRC

#+RESULTS:
: sum_args
: accept arbitrary numerical arguments and return their sum
: 6

*** 名称空间
函数默认将变量绑定到局部名称空间，要使用全局的名字，
就需要在函数中作如下声明。
#+BEGIN_SRC python
  global indentifiers
#+END_SRC

*** 匿名函数
#+BEGIN_SRC python
  lambda parameters: expression
#+END_SRC

*** 生成器
#+BEGIN_SRC python
  yield expression
#+END_SRC

#+BEGIN_SRC python :results output :exports both
  def updown(n):
      for x in range(n):
          yield x
      for x in range(n - 1, -1, -1):
          yield x
  for i in updown(10):
      print i,
#+END_SRC

#+RESULTS:
: 0 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0

* 语法陷阱
** 兼容性问题
兼容性问题主要是指Python2和Python3的兼容性。
*** 输入和输出

在python2中print是一个表达式，在python3中print是一个函数，
也就是说python2程序员写的print代码在python3下都不能运行。

在python2中的input函数会计算用户的输入，要防止计算就必须用raw_input，
而python3中将raw_input删除了，而input的含义等同于python2中的raw_input。

这些更改看上去更美好了，但是总感觉那么忧伤。


*** dict.items
在python2中字典有两个迭代函数。
- items(...) ::
     D.items() -> list of D's (key, value) pairs, as 2-tuples
- iteritems(...) ::
     D.iteritems() -> an iterator over the (key, value) items of D
很显然python2的程序员为了空间效率都会去调用 =iteritems()=，
但奇葩的python3将其删除了，只保留了items()，含义如下：
- items(...) ::
     D.items() -> a set-like object providing a view on D's items

** 奇怪的语法
*** 单元素元组
要定义单个元素的元组，必须加上一个逗号，否则就成了单个整数。
#+BEGIN_SRC sh
a = (41,)
#+END_SRC

这种丑陋的写法其实无可厚非，毕竟你为什么要创建单个元素的元组呢。
*** 循环分支
下面语句的else表示完整遍历了循环，无论怎样，看上去很怪。
从形式上看，没有执行循环去访问else更加合理。
#+BEGIN_SRC python :exports both :results output
while 0:
    pass
else:
    print "over all"
#+END_SRC

#+RESULTS:
: over all

** 特殊函数
*** 慎用 =__del__=
文章 [[http://www.708luo.com/posts/2015/04/python-del-method/][慎用python的__del__方法]] 比较详细分析了这个缺陷。
=__del__= 相当于C语言中的析构函数，但是问题是它不一定被调用。
也就是说如果你实现了 =__del__= 方法就不能出现循环引用，
否则垃圾回收器将因为不知道释放顺序而放弃释放。
下面是一个示例。

#+BEGIN_SRC python :exports both :results output
class A(object):
    def __init__(self, parent):
        print "A init"
        self.parent = parent

    def __del__(self):
        print "A del"

class B(object):
    def __init__(self):
        print "B init"
        self.child = A(self)

    def __del__(self):
        print "B del"

b = B()
#+END_SRC

#+RESULTS:
: B init
: A init

就凭这一点，程序员应该不要去实现 =__del__= 函数，
当然这个问题应该归罪于Python本身，既然有这么严重的问题，
就不应该给用户提供接口。

* 常用模块
** subprocess
subprocess模块位于Python标准库的[[https://docs.python.org/2/library/ipc.html][Interprocess Communication and Networking]]部分，
subprocess模块非常强大，可以创建新的进程，连接到其他管道，获取返回值等，
官方希望用这个模块替代 os.system、os.spawn*、os.popen*、popen2.*和commands.*
等模块/函数。至于为什么要使用这个模块可以参考[[https://www.python.org/dev/peps/pep-0324/][PEP 324]]的说明。
要替换以前的函数也不难，比方os.system()可以用subporcess.call()来替代。

*** Popen类
subprocess中定义了一个Popen类，如下所示。
#+BEGIN_SRC python
class Popen(args, bufsize=0, executable=None,
            stdin=None, stdout=None, stderr=None,
            preexec_fn=None, close_fds=False, shell=False,
            cwd=None, env=None, universal_newlines=False,
            startupinfo=None, creationflags=0):
#+END_SRC
- args :: 字符串或程序参数序列，当指定shell=True时，因为所有参数都是传递给shell，
     所以实际上并不需要写成序列形式，可以所有参数直接写到一个字符串中。
- bufsize :: 默认不缓冲，如果指定为负数，就使用系统默认缓冲大小。
- stdin :: 可以指定为PIPE、文件描述符、文件对象和None。
- close_fds :: 执行子进程时将关闭所有文件描述符，标准输入输出例外。
- cwd :: 指定当前目录。
- env :: 为子进程定义环境变量。


Popen类中常用方法如下：
- poll() :: 检查进程是否结束，返回返回值
- wait() :: 等待进程结束，返回返回值
- communicate(input=None) :: 返回一个元组，(stdout, stderr)

Popen类中常用变量如下
- stdin :: 如果参数设置为PIPE，该属性就是一个文件对象
- pid :: 进程号
- returncode :: 返回值

*** subprocess
常用方法：
#+BEGIN_SRC python
subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)
subprocess.check_call(args, *, stdin=None, stdout=None, stderr=None,
                      shell=False)
subprocess.check_output(args, *, stdin=None, stderr=None, shell=False,
                        universal_newlines=False)
#+END_SRC
注意，最好不要将stdout/stderr设置为PIPE，要设置的话请使用Popen类，
因为将stdout/stderr设置为PIPE有死锁的风险。
- check_call :: 正常返回0，当子进程返回值不为0的时候产生CalledProcessError。
- check_output :: 返回输出字符串，当子进程返回值不为0时产生CalledProcessError。

常用变量：
#+BEGIN_SRC python
subprocess.PIPE
subprocess.STDOUT
exception subprocess.CalledProcessError
#+END_SRC

*** 替代方法
推荐参考[[https://docs.python.org/2/library/subprocess.html#replacing-older-functions-with-the-subprocess-module][17.1.4. Replacing Older Functions with the subprocess Module]]这部分内容。

#+BEGIN_SRC python
# ls -l
output = Popen(["ls", "-l"], stdout=PIPE).communicate()[0]

# dmesg | grep hda
p1 = Popen(["dmesg"], stdout=PIPE)
p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
output = p2.communicate()[0]
#+END_SRC

#+BEGIN_SRC python
# ls -l
p = Popen("ls -l", shell=True)
stat = os.waitpid(p.pid, 0)
#+END_SRC
更好的写法是这样的。
#+BEGIN_SRC python
try:
    retcode = call("ls -l", shell=True)
    if retcode < 0:
        print >>sys.stderr, "Child was terminated by signal", -retcode
    else:
        print >>sys.stderr, "Child returned", retcode
except OSError, e:
    print >>sys.stderr, "Execution failed:", e
#+END_SRC

* 单元测试
首先要理解测试用例的概念。
- 自动运行，不需要人工输入
- 自动确定结果，不用人为判断结果的正确性
- 独立运行，每个用例可以单独运行

#+BEGIN_SRC python
import unittest

class KnownValues(unittest.TestCase):
    """to_roman should give known result with known input"""
    known_values = ((1, 'I'),
                    (2, 'II'),
                    ...,
                    (3999, 'MMMCMXCIX'))
    def test_to_roman_known_values(self):
        for integer, numeral in self.known_values:
            result = roman1.to_roman(integer)
            self.assertEqual(numeral, result)


if __name__ == '__main__':
    unittest.main()
#+END_SRC
- assertEqual :: 当发现错误时，会抛出异常，并且测试不通过。
- unittest.main() :: 对每一个测试用例，unittest模块都会打印其文档字符串。

除了要测试正常用例，还需要输入非正常用例，让其能够在预料的情况下工作。
错误用例的写法如下所示，当然也可以将用例都写入到一个class，
这里分开主要是便于分类。
#+BEGIN_SRC python
class ToRomanBadInput(unittest.TestCase):
    def test_too_large(self):
        '''to_roman should fail with large input'''
        self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
#+END_SRC

接下来可以看看基本代码。
#+BEGIN_SRC python
class OutOfRangeError(ValueError):
    pass

class NotIntegerError(ValueError):
    pass

def to_roman(n):
    '''convert integer to Roman numeral'''
    if not isinstance(n, int):
        raise NotIntegerError('non-integers can not be converted')
    if not (0 < n < 4000):
        raise OutOfRangeError('number out of range (must be less than 4000)')

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result
#+END_SRC

当然在ToRomanBadInput类中，还可以添加很多测试，比如值过小，负数，类型错误等等。

如果我们写好了to_roman()函数，要测试from_roman()就非常容易了。
利用如下恒等式可以快速编写测试用例。
#+BEGIN_SRC python
n = from_roman(to_roman(n))
#+END_SRC

编写from_roman()是很困难的，因为识别非法字符串就很很困难。
- 字符可相加也可能相减：I->1、II->2、III->3、VI->6、VII->7、VIII->8、IX->9等等
- IXCM可以连续重复最多三次
- VL不能连续重复
#+BEGIN_SRC python
roman_numeral_pattern = re.compile('''
^                # beginning of string
M{0,3}           # thousands - 0 to 3 Ms
(CM|CD|D?C{0,3}) # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),
                 # or 500-800 (D, followed by 0 to 3 Cs)
(XC|XL|L?X{0,3}) # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),
                 # or 50-80 (L, followed by 0 to 3 Xs)
(IX|IV|V?I{0,3}) # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),
                 # or 5-8 (V, followed by 0 to 3 Is)
$                # end of string
''', re.VERBOSE)

def from_roman(s):
    """convert Roman numeral to integer"""
    if not roman_numeral_pattern.search(s):
        raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))
    result = 0
    index = 0
    for numeral, integer in roman_numeral_map:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
#+END_SRC

* 参考资料
- [[http://www.diveintopython3.net/][Dive Into Python 3]]
- [[http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html][PyCoder’s Weekly 中文翻译]]
- [[https://docs.python.org/2/library/subprocess.html][17.1. subprocess — Subprocess management]]
- [[https://docs.python.org/3/library/argparse.html][Python3: 16.4. argparse — Parser for command-line options, arguments and sub-commands]]
- [[https://docs.python.org/2/howto/argparse.html][Python2: Argparse Tutorial]]
- [[http://pymotw.com/2/argparse/][Python2: argparse – Command line option and argument parsing]]
- [[http://youngsterxyf.github.io/2013/03/30/argparse/][Python2: argparse – Command line option and argument parsing（中文）]]

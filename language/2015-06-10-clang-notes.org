#+TITLE: C语言笔记
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil
#+LATEX_CLASS: latex-doc
#+PAGE_TAGS: clang

* 陷阱与缺陷
** 陷阱
*** 访问越界
#+HTML: <!--abstract-begin-->

#+BEGIN_SRC cpp :includes <stdio.h>
int a[10];
int i;
for (i = 0; i <= 10; i++) {
    a[i] = 0;
    printf("a[%d] = %d, ", i, a[i]);
}
#+END_SRC

如果编译器按照内存地址递减的顺序给变量分配空间，那么a[10]对应的实际就是变量i，
在循环到i=10的时候又将i复位为0，这就会引起一个有趣的现象，那就是循环变成一个死
循环。
#+HTML: <!--abstract-end-->

*** 进制误用
#+BEGIN_SRC cpp
struct {
    int part_number;
    char *description;
} part_table[] = {
    027, "windows"
    077, "linux"
    123, "others"
};
#+END_SRC

这里企图用0来对其，但是编译器会将027/077视为八进制数据，很可能这不是程序编写者的意图。

*** 优先级误用
#+BEGIN_SRC cpp
if (flags & NEED_READ != 0)             // A
    read_data();

r = hi << 4 + low;                      // B

while (c = getc(in) != EOF)             // C
    putc(c, out);
#+END_SRC
A处先执行逻辑比较再进行位运算，B处先计算加法再计算移位，
C处先比较getc()和EOF是否不相等，再把比较结果传递给变量c。
很可能本意不是如此，因此这种情况最好用括号说明。

括号是超越优先级的存在，运算符口诀如下：
#+BEGIN_VERSE
成员-单目-乘-加减，移位-大小-不相等，
按位与-异-或-逻辑，三目-赋值-逗号低。
#+END_VERSE
- 成员 :: 包括四个运算符：() [] -> .
     需要注意这里的括号是指函数调用，而不是通常意义的括号。

*** 溢出
#+BEGIN_SRC cpp
if (a + b < 0)                          // A
    printf("out of range\n");
#+END_SRC
A处企图用两个整型相加的结果为负来判断是否溢出，但是这样的方法并不正确，
例如某些机器上溢出会产生一个溢出状态，此时的结果就不为负数。
比较简单的方式是通过 =a > INT_MAX - b= 来判断，
此外也可以将其转换为无符号整数来判断。


*** 输入输出陷阱
#+BEGIN_SRC cpp :includes <stdio.h>
int i;
char c;

for (i = 0; i < 5; i++) {
    scanf("%d", &c);
    printf("%d ", i);
}
#+END_SRC

这部分代码的关键问题是c被声明为char类型，而在输入时又当作整型数，会导致变量c附
近的内存被覆盖。

*** 自动变量
#+BEGIN_SRC cpp
#define BUFSIZE         1024
int main()
{
    int c;
    char buf[BUFSIZE];

    setbuf(stdout, buf);
    while((c = getchar()) != EOF)
        putchar(c);

    return 0;
}
#+END_SRC
在main函数运行之后，将会刷新缓存，而此时作为自动变量的buf已经被释放了。
可以通过将buf定义为静态变量避免这个问题。

*** 函数原型
#+BEGIN_SRC cpp
int isvowel(c)
    char c;
{
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' ||
        c == 'u';
}
#+END_SRC

在很多库函数中能看到这样的写法，这种写法主要是为了与老的编译器兼容，
老的编译器不支持指定函数参数类型，所以在传递参数时会默认转换为int，
这种写法和如下写法等价。
#+BEGIN_SRC cpp
int isvowel(int i)
{
    char c = i;
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' ||
        c == 'u';
}
#+END_SRC

*** errno
不要在正常返回的情况下检查errno，因为即便所调用的函数返回正确，也可能在函数中又
调用了其他函数，而其他函数有可能会设置errno。

*** signal
信号可能出现在某些复杂的库函数中，如果signal处理函数中再调用这样的函数，
结果可能导致不堪设想的后果。

假设malloc执行过程被一个信号中断，此时malloc用于追踪可用内存的数据结构可能只有
部分更新，如果在signal处理函数中再调用malloc，就可能让malloc完全崩溃。

同样在signal中使用longjmp也不安全，因为信号可能发生在malloc更新数据结构的过程中，
因此signal处理函数能够做的安全的事情就是设置一个标志然后返回，期待主程序检查到
这个标志。对于算术运算，这样也是不安全的，某些机器在信号处理函数返回时还会重新
执行失败的操作，而我们又没有办法更新操作数，故此时唯一安全可移植的办法就是打印
一条出错消息，然后用longjmp/exit退出程序。

*** 宏
不要对宏执行有副作用的代码。
#+BEGIN_SRC cpp
#define max(a, b) ((a) > (b) ? (a) : (b))

int c = max(a++, ++b);                  // A

#define TP struct table *
TP a, b;                                // B
#+END_SRC
将A处展开之后变为 =(a++) > (++b) ? (a++) : (++b)= ，可能导致任意一个变量自增两次。
在B处存在一个问题是变量a是指针，但是变量b不是指针。

一个典型的assert宏可以定义为如下形式。
#+BEGIN_SRC cpp :includes <stdio.h>
#define assert_err(x)                                           \
    if (!x) printf("%s, %d: %s\n", __FILE__, __LINE__, #x)

int init_value = 1;
assert_err(init_value - 1);
#+END_SRC

如果一个宏当中包含多个语句，应当使用如下的形式。
#+BEGIN_SRC cpp
#define __set_TM1x(XI,V)                        \
    do {                                        \
        int shift = (XI) * 2 + 16;              \
        unsigned long tm1 = __reg(0xfeff9808);  \
        tm1 &= ~(0x3 << shift);                 \
        tm1 |= (V) << shift;                    \
        __reg(0xfeff9808) = tm1;                \
        mb();                                   \
    } while(0)
#+END_SRC
不能简单用大括号包围，因为遇到if-else语句就会打断if-else，
这种情况只能用do-while包围。

** 缺陷
*** 整型数
#+BEGIN_SRC cpp :includes '(<limits.h> <stdio.h>)
printf("%d", INT_MAX);
#+END_SRC

右移位的时候，如果是一个负数，那么高位可能是由0填充，也可能是由符号位填充，
因此可移植的办法是使用无符号类型来右移位。
此外移位的数目应该要保证大于等于0，并且严格小于对象的位长。
对于负数，右移一位并不等于除以2，举例来说，(-1) >> 1 一般不会是0，
而(-1) / 2则为0。当然如果知道数值为非负，那么用移位来代替除法是没有问题的。

** 特性
*** inline
如果编译器不优化，inline就是普通函数，更便于调试，
调试好了之后采用优化重新编译，inline函数就像宏一样融入代码。

*** attribute
为了兼容老的代码，因为在早期inline不是关键字，
gcc允许使用__inline__、__asm__等代替无下划线的形式。

#+BEGIN_SRC cpp
struct x86_hw_tss {
    u32                     reserved1;
    u64                     sp0;
    u64                     sp1;
    ...
} __attribute__((packed)) ____cacheline_aligned;
#+END_SRC
- packed :: 表示成员字段不用对齐
- ____cacheline_aligned :: 整个数据结构按照高速缓存行的大小对齐

*** struct
结构体的点操作符可以帮助我们访问结构的成员，反过来如果我们知道当前结构或数据类型属于某个结构体，
也可以利用存储特性由成员获取结构体。
举一个例子，请看如下代码。
#+BEGIN_SRC cpp
struct person {
    char name[10];
    int age;
    int id;
    struct infomation info;
};

struct person *get_person(struct infomation *info)
{
    // ?
}

int test_get_person(void)
{
    struct person p;
    return &p == get_person(&p.info);
}
#+END_SRC
在Linux内核中大量的运用到了get_person()这样的函数，或者说宏，
因为使用量很大，所以都是以宏的形式实现。实现的关键思路就是在struct的表示中，
成员地址相对于结构体的首地址偏移量是固定的。
典型的宏定义如下。
#+BEGIN_SRC cpp
/**
 ,* container_of - cast a member of a structure out to the containing structure
 ,* @ptr:        the pointer to the member.
 ,* @type:       the type of the container struct this is embedded in.
 ,* @member:     the name of the member within the struct.
 ,*
 ,*/
#define container_of(ptr, type, member) ({                              \
            const typeof( ((type *)0)->member ) *__mptr = (ptr);        \
            (type *)( (char *)__mptr - offsetof(type,member) );})
#+END_SRC

有了这个宏，问号处的代码就很清晰了，直接写 =return container_of(info, struct person, info)= 即可。
** 习题
#+BEGIN_QUOTE
C语言中使用 =/* ... */= 作为注释，设计一个在允许嵌套注释和不允许嵌套注释条件下
都能通过编译的代码，但是在不同代码条件下执行结果不同。
#+END_QUOTE

#+BEGIN_SRC cpp
int a = /*/*/0*/**/1;
char *b = /*/**/"*/"/*"/**/;
#+END_SRC

| 变量 | 允许嵌套 | 不允许嵌套 |
|------+----------+------------|
| a    | 1        | 0          |
| b    | "/*"     | "*/"       |


#+BEGIN_QUOTE
（1） 如何调用地址为0的函数，假定函数无参数，无返回值。

（2） signal函数接受两个参数，一个代表特定信号的整型数值，
一个代表用户提供的函数指针，用户提供的函数只有一个整型的参数，无返回值。
signal函数返回值和用户提供的函数类型相同。
#+END_QUOTE
#+BEGIN_SRC cpp
(*(void (*)()) 0)();                      // (1)
void (*signal(int, void (*)(int))) (int); // (2)
#+END_SRC
更加容易理解的写法如下。
#+BEGIN_SRC cpp
typedef void (*func0) ();               // (1)
(*(func0)0) ();

typedef void (*handler) (int);          // (2)
handler signal(int, handler);
#+END_SRC

#+BEGIN_QUOTE
将long整形以十进制输出，接口如下。

void printnum(long n);
#+END_QUOTE

#+BEGIN_SRC cpp :includes <stdio.h>
void printchar(char c)
{
    printf("%c", c);
}
void printnum(long n, char c)
{
    if (n < 0) {
        printchar('-');
        n = -n;
    }

    if (n >= 10)
        printnum(n / 10, 0);

    printchar(n % 10 + '0');

    if (c)
        printchar(c);
}
#define printn(n) printnum(n, '\n')
int main()
{
    printn(0x192);
    printn(-0x192);
    return 0;
}
#+END_SRC




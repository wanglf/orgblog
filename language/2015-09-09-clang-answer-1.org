#+TITLE: C/C++习题解答1
#+AUTHOR: Micky Ching
#+OPTIONS: H:4 ^:nil
#+LATEX_CLASS: latex-doc
#+PAGE_TAGS: clang C++

* C语言习题
** 关键字解释
1. register用于告诉编译器这是常用变量，请放到寄存器中。
   现在一般并不希望由用户来定义，而是有编译器自动分析，
   所以这个关键字名存实亡了。

* C++习题

** 类的基本概念
*** 成员函数
#+HTML: <!--abstract-begin-->

1. 构造函数是用来初始化对象的，不能有返回值。
   构造函数相比于其它函数有其特别之处，可以使用初始化列表，
   初始化列表先于函数体执行。
   要注意的是如果要使用默认参数，需要在声明处指定，而不是定义的时候才指定。

   析够函数是用来释放对象的，不能有参数，因此不能重载。

   多个文件的全局变量构造函数调用顺序不确定，
   静态对象在函数首次调用时创建，程序退出时释放。

#+HTML: <!--abstract-end-->

2. 同一个类中不允许对函数重定义，但是在继承层次中却允许不同层次去定义相同的函数，
   以实现在不同层次完成不同的功能。
   这又有两种方式，一种是静态绑定，即以什么样的形式传入，就调用什么形式的函数，
   一种是动态绑定，不论以什么形式传入，都调用其本身的函数。
   动态绑定其实就是借助基类的指针或引用来调用本质定义，而不是形式定义。
   两种绑定方式又可以描述为早期绑定和晚绑定，即前者在编译期确定，
   后者在编译时不会直接插入函数地址，而是一段汇编代码。

   此外面临的一个问题是对于一个函数在哪个层次开始动态绑定，这个也很容易理解，
   从上往下，哪个层次最先出现 =virtual=，哪个层次就最先实现动态绑定，
   向下自动继承 =virtual= 特性。

   虚函数不能使用默认参数，因为默认参数是静态绑定，如果子类改写默认参数，
   会出现调用子类虚函数，仍然使用父类虚函数中的默认参数！

   下面的概念比较绕：
   子类未改写普通函数调用已改写的虚函数时，则调用的是已改写过的虚函数。
   子类未改写普通函数调用已改写普通函数时，则调用的是父类的普通函数。

   为了能够正确释放子类，析够函数必须指定为虚函数。

   纯虚函数用于定义抽象基类/虚基类，阻止实例化。
   为了能够实例化，子类必须定义所有抽象接口。

   *重载* 同名不同形，即参数不同

   *重定义* 子类定义和父类相同函数

   *重写* 子类定义和父类相同虚函数

   虚继承用于解决多重继承模糊问题，如A中定义了 =print=，
   B、C继承于A，而D继承于B、C，当D调用 =print= 时，
   无法知道该用B还是C的，用虚继承则可以让其只有一个拷贝，
   都指向同一 =print= 函数。
   #+BEGIN_SRC cpp
class A;                                // 1B
class B: public vitual A;               // 4B
class C: public vitual A;               // 4B
class D: public B, public C;            // 8B
   #+END_SRC

   构造函数不能是虚函数，因为调用虚函数需要借助虚函数表，
   但此时还没有构造，故无虚函数表可用。
   比较有趣的inline virtual，编译器可以跳过虚表直接调用，
   甚至可以内联展开。
   此外成员模板函数也不能是虚函数。

** 内存管理
1. 智能指针关键是重载 =->= 操作符，为了判定指向是否为空，
   需要用 =ptr.get()= 获取裸指针和NULL比较。

   std::auto_ptr实际只能管理单个堆对象，因为执行赋值操作时，
   原来的指针被reset。这个行为如此奇怪，所以最终也被新的标准抛弃。
   也正是这个糟糕的设计使得使用起来非常困难，不能作为参数进行值传递，
   不能放入vector等等。

   boost::scoped_ptr和auto_ptr设计思路是一致的，都是管理单个堆对象，
   但是没有提供赋值操作符，所以被强制限定了，这至少能防止误用。

   boost::shared_ptr利用引用计数来确定何时释放，也是用于管理单个堆对象。

   boost:scoped_array用于管理动态数组，同样不允许赋值。

   boost:shared_array也是利用引用计数，管理动态数组。

   boost::weak_ptr的存在是为了解决每次使用shared_ptr都会增加引用计数。
   weak_ptr是一个观察者，它本身不会增加引用计数。

   boost:instrusive_ptr机理和shared_ptr一样，
   只不过把引用计数的任务推给对象本身而已。
